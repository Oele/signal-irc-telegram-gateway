#!/usr/bin/perl -w
#
# Webhook for Hermod Telegram Gateway Bot. The hook can be set by the command:
#
# curl -F "url=https://webserver/cgi-bin/telehook" https://api.telegram.org/bot$TOKEN/setWebhook
#
# messages are filtered a little and then written
# to a logfile, for processing by the bot
#
# 2019-08-17, Ruben de Groot

use strict;
use CGI qw/:standard/;
use HTTP::Tiny;
use JSON;
use Text::Unidecode;

open my $fh, '<', "/etc/hermod.json" or die "error opening configuration $!";
my $cfg = decode_json do { local $/; <$fh> };

my $ok = '{"ok":true,"result":true}';

# communicate with bot through a logfile
open my $irc, '>>:utf8', $cfg->{irc}->{infile} or die "error opening $cfg->{irc}->{infile}\n";
open my $sig, '>>:utf8', $cfg->{signal}->{infile} or die "error opening $cfg->{signal}->{infile}\n";
open my $dbg, '>>:utf8', $cfg->{telegram}->{debug} if defined $cfg->{telegram}->{debug};

my $cgi    = CGI->new;
my $body = (defined $cgi->param('POSTDATA')) ? $cgi->param('POSTDATA') : '{}';
my $dj = decode_json( $body );

print $dbg "$body\n" if defined $cfg->{telegram}->{debug};

# check type of msg and chat_id
finish("no chat id\n") unless defined $dj->{message}->{chat}->{id};
finish("wrong chat id\n") unless $dj->{message}->{chat}->{id} == $cfg->{telegram}->{chat_id};

my $user_id = (defined $dj->{message}->{from}->{id} and $dj->{message}->{from}->{id} =~ /^\d+$/) ?
    $dj->{'message'}->{'from'}->{id} : 0;
my $text = (defined $dj->{message}->{text}) ? $dj->{message}->{text} : "";
my $first = (defined $dj->{message}->{from}->{first_name}) ? $dj->{message}->{from}->{first_name} : "";
my $last = (defined $dj->{message}->{from}->{last_name}) ? $dj->{message}->{from}->{last_name} : "";
my $caption = (defined $dj->{message}->{'caption'}) ? $dj->{message}->{caption} : "";

# look for photo's and documents
my ($type,$doc);
if (defined $dj->{message}->{photo}) {
    $doc = @{$dj->{message}->{photo}}[-1];
    $type = 'photo';
}
if (defined $dj->{message}->{document}) {
    $doc = $dj->{message}->{document};
    $type = 'document';
}

if (defined $doc->{file_id}) {
    my $response = HTTP::Tiny->new->get( "https://api.telegram.org/bot$cfg->{telegram}->{token}/getFile?file_id=$doc->{file_id}" );
    if ($response->{success}) {
        my $djfile = decode_json( $response->{content} );
        my $path = $djfile->{result}->{file_path};
        (my $file = $path) =~ s#.*/##;
        my $name = (defined $doc->{file_name}) ? $doc->{file_name} : $file;
        qx( wget -O $cfg->{telegram}->{attachments}/$file https://api.telegram.org/file/bot$cfg->{telegram}->{token}/$path >/dev/null 2>&1 );
        if ($? == 0) {
            print $sig "FILE:$file [send by $first $last on telegram] $caption\n";
            $text = "** sends a $type: $cfg->{telegram}->{url}/$file";
            $text .= " with caption: $caption" if $caption;
        } else {
            print $dbg "Error getting $type $name $file\n";
        }
    }
}

$text .= "\nsends a sticker" if defined $dj->{message}->{sticker};

# is the message a reply?
$text = "(reply to: $dj->{message}->{reply_to_message}->{text}) " . $text if defined $dj->{message}->{reply_to_message} and
    $dj->{message}->{reply_to_message}->{text};

# look for new chat members
if (defined $dj->{message}->{new_chat_members}) {
    my $members = '';
    foreach my $member (@{$dj->{message}->{new_chat_members}}) {
        $members .= ', ' if $members;
        $members .= "$member->{first_name} $member->{last_name}";
    }
    $text = "[Tg] $members joined the chat\n";
    print $irc $text;
    print $sig $text;
    finish("New member(s): $members\n");
}

# look for leaving chat members
if (defined $dj->{message}->{left_chat_member}) {
    $text = "[Tg] $dj->{message}->{left_chat_member}->{first_name} left the chat\n";
    print $irc $text;
    print $sig $text;
    finish("Leaving member: $dj->{message}->{left_chat_member}->{first_name}\n");
}

# split lines and write to logs for signal and irc
my @lines = split /\n/, $text;
for (@lines) {
    next unless $_;
    my $msg = "[Tg] $first $last: $_\n";

    # for IRC, split in chunks of maxmsg size if necessary 
    if (defined $cfg->{irc}->{maxmsg} and length $msg > $cfg->{irc}->{maxmsg}) {
        my $ircmsg = $msg;
        while (my $chunk = substr $ircmsg, 0, $cfg->{irc}->{maxmsg}) {
            print $irc "$chunk\n";
            last if length $ircmsg <= $cfg->{irc}->{maxmsg};
            $ircmsg = "[Tg] $first $last: " . substr $ircmsg, $cfg->{irc}->{maxmsg};
        }
    } else {
        print $irc $msg;
    }
    # skip documents, photo's. they've been send already.
    next if $msg =~ /\*\* sends a /;
    print $sig $msg;
}

finish("Relayed messages\n");

print "https://xkcd.com/2200/\n";

sub finish {
    print $dbg shift if defined $cfg->{telegram}->{debug};
    print $cgi->header(-type => 'application/json', -connection => 'close');
    print $ok."\n\n";
    exit();
}
