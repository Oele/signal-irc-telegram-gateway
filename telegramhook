#!/usr/bin/perl -w
#
# Webhook for Hermod Telegram Gateway Bot. The hook can be set by the command:
#
# curl -F "url=https://webserver/cgi-bin/telehook" https://api.telegram.org/bot$TOKEN/setWebhook
#
# messages are filtered a little and then written
# to a logfile, for processing by the bot
#
# 2019, Ruben de Groot

use strict;
use CGI::Fast qw/:standard/;
use HTTP::Tiny;
use JSON;
use Text::Unidecode;
use DBI;

open my $fh, '<', "/etc/hermod.json" or die "error opening configuration $!";
my $cfg = decode_json do { local $/; <$fh> };

# communicate with bot through a logfile
open my $irc, '>>:utf8', $cfg->{irc}->{infile} or die "error opening $cfg->{irc}->{infile}\n";
open my $sig, '>>:utf8', $cfg->{signal}->{infile} or die "error opening $cfg->{signal}->{infile}\n";
open my $dbg, '>>:utf8', $cfg->{telegram}->{debug} if defined $cfg->{telegram}->{debug};

# bots cannot get a list of group members, so we keep a database
my $dbh = DBI->connect("dbi:SQLite:dbname=$cfg->{telegram}->{db}", "", "", { RaiseError => 1 }, )
        if defined $cfg->{telegram}->{db};
my $stmt = $dbh->prepare("insert into teleusers (id,first_name,last_name,username,is_bot) values (?,?,?,?,?)")
        if defined $dbh;

sub ok {
    my $msg = shift;
    print $dbg $msg if defined $msg and defined $dbg;
    print CGI->header(-type => 'application/json');
    print '{"ok": true, "status": 200}'."\n\n";
    exit;
}

while (my $cgi = CGI::Fast->new) {
    my $body = (defined $cgi->param('POSTDATA')) ? $cgi->param('POSTDATA') : '{}';
    my $dj = decode_json( $body );
    
    print $dbg "$body\n" if defined $cfg->{telegram}->{debug};
    
    # check type of msg and chat_id
    if (defined $dj->{message}->{chat}->{id} and $dj->{message}->{chat}->{id} == $cfg->{telegram}->{chat_id}) {
    
        my $user_id = (defined $dj->{message}->{from}->{id} and $dj->{message}->{from}->{id} =~ /^\d+$/) ?
            $dj->{'message'}->{'from'}->{id} : 0;
        my $text = (defined $dj->{message}->{text}) ? $dj->{message}->{text} : "";
        my $first = (defined $dj->{message}->{from}->{first_name}) ? $dj->{message}->{from}->{first_name} : "";
        my $last = (defined $dj->{message}->{from}->{last_name}) ? $dj->{message}->{from}->{last_name} : "";
        my $caption = (defined $dj->{message}->{caption}) ? $dj->{message}->{caption} : "";
        
        # look for photo's and documents
        my ($type,$doc);
        if (defined $dj->{message}->{photo}) {
            $doc = @{$dj->{message}->{photo}}[-1];
            $type = 'photo';
        }
        foreach my $t ('voice', 'audio', 'document') { 
            if (defined $dj->{message}->{$t}) {
                $doc = $dj->{message}->{$t};
                $type = $t;
            }
        }
        
        if (defined $doc->{file_id}) {

            # download the file
            my $response = HTTP::Tiny->new->get( "https://api.telegram.org/bot$cfg->{telegram}->{token}/getFile?file_id=$doc->{file_id}" );
            if ($response->{success}) {
                my $djfile = decode_json( $response->{content} );
                my $path = $djfile->{result}->{file_path};
                (my $file = $path) =~ s#.*/##;
                my $name = (defined $doc->{file_name}) ? $doc->{file_name} : $file;
                qx( wget -O $cfg->{telegram}->{attachments}/$file https://api.telegram.org/file/bot$cfg->{telegram}->{token}/$path >/dev/null 2>&1 );
                if ($? == 0) {
                    print $sig "FILE:$file [sent by $first $last on telegram] $caption\n";
                    $text = "** sends $type: $cfg->{telegram}->{url}/$file";
                    $text .= " with caption: $caption" if $caption;
                } else {
                    print $dbg "Error getting $type $name $file\n";
                }
            }
        }
        
        $text .= "\nsends a sticker" if defined $dj->{message}->{sticker};
        
        # is the message a reply?
        $text = "(reply to: $dj->{message}->{reply_to_message}->{text}) " . $text if defined $dj->{message}->{reply_to_message} and
            $dj->{message}->{reply_to_message}->{text};
        
        # is the message forwarded from another channel?
        if (defined $dj->{message}->{forward_from_chat} and defined $cfg->{telegram}->{forward}) {

            $text = "[$dj->{message}->{forward_from_chat}->{title}]: $dj->{message}->{text}\n";
            print $irc $text;
            print $sig $text;
            ok("forwarded msg: $dj->{message}->{text} from $dj->{message}->{forward_from_chat}->{title}\n");

        } elsif (defined $dj->{message}->{forward_from_chat}) {

            # don't forward; let twitterpoller handle this
            ok("NOT forwarded msg: $dj->{message}->{text} from $dj->{message}->{forward_from_chat}->{title}\n");
        }
        
        # look for new chat members
        if (defined $dj->{message}->{new_chat_members}) {
            my $members = '';
            foreach my $m (@{$dj->{message}->{new_chat_members}}) {
                $stmt->execute($m->{id},$m->{first_name},$m->{last_name},$m->{username},$m->{is_bot}) if defined $stmt;
                $members .= ', ' if $members;
                $members .= "$m->{first_name} $m->{last_name}";
            }
            $text = "[Tg] $members joined the chat\n";
            print $irc $text;
            print $sig $text;
            ok("New member(s): $members\n");
        }
        
        # look for leaving chat members
        if (defined $dj->{message}->{left_chat_member}->{id}) {
            $dbh->do("delete from teleusers where id = $dj->{message}->{left_chat_member}->{id}") if defined $dbh;
            $text = "[Tg] $dj->{message}->{left_chat_member}->{first_name} left the chat\n";
            print $irc $text;
            print $sig $text;
            ok("Leaving member: $dj->{message}->{left_chat_member}->{first_name}\n");
        }

        # split lines and write to logs for signal and irc
        my @lines = split /\n/, $text;
        for (@lines) {
            next unless $_;
            my $msg = "[Tg] $first $last: $_\n";
        
            # for IRC, split in chunks of maxmsg size if necessary 
            if (defined $cfg->{irc}->{maxmsg} and length $msg > $cfg->{irc}->{maxmsg}) {
                my $ircmsg = $msg;
                while (my $chunk = substr $ircmsg, 0, $cfg->{irc}->{maxmsg}) {
                    print $irc "$chunk\n";
                    last if length $ircmsg <= $cfg->{irc}->{maxmsg};
                    $ircmsg = "[Tg] $first $last: " . substr $ircmsg, $cfg->{irc}->{maxmsg};
                }
            } else {
                print $irc $msg;
            }
            # skip documents, photo's. they've been sent already.
            next if $msg =~ /\*\* sends /;
            print $sig $msg;
        }
    }
    ok();
}
