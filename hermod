#!/usr/bin/perl
#
# IRC Bot for Hermod Telegram Gateway. Reads from a logfile to be send to irc and relays
# messages from irc to telegram and to another logfile which is send to a signal group
# by signalpoller.
# When twitter is configured, check for status updates of a twitter account and relay those.
#
# 2019, Ruben de Groot

use strict;
use POE qw(Component::IRC Component::IRC::Plugin::FollowTail Component::SSLify);
use HTTP::Tiny;
use URI::Escape;
use JSON qw( decode_json );
use Net::Twitter;
use DBI;

open my $fh, '<', "/etc/hermod.json" or die "error opening configuration $!";
my $cfg = decode_json do { local $/; <$fh> };
close $fh;
open my $dbg, ">>", $cfg->{irc}->{debug} if defined $cfg->{irc}->{debug};

my $URL = "https://api.telegram.org/bot$cfg->{telegram}->{token}/sendMessage";

# We create a new PoCo-IRC object
my $irc = POE::Component::IRC->spawn(
   nick     => $cfg->{irc}->{nick},
   ircname  => $cfg->{irc}->{ircname},
   username => $cfg->{irc}->{ident},
   server   => $cfg->{irc}->{node},
   Port     => $cfg->{irc}->{port},
   UseSSL   => $cfg->{irc}->{UseSSL},
) or die "Oh noooo! $!";

POE::Session->create(
    package_states => [
        main => [ qw(_default _start irc_001 irc_public irc_join irc_quit irc_tail_input irc_ctcp_action ) ],
    ],
    heap => { irc => $irc },
);

POE::Session->create(
    inline_states => {
      _start => sub {
        $_[KERNEL]->delay(tick => 60);
      },
      tick => sub {
        &twitterpoll;
        $_[KERNEL]->delay(tick => $cfg->{twitter}->{tick});
      },
    },
) if defined $cfg->{twitter}->{tick};

my $nt = Net::Twitter->new(
    traits   => [qw/API::RESTv1_1/],
    consumer_key        => $cfg->{twitter}->{consumer_key},
    consumer_secret     => $cfg->{twitter}->{consumer_secret},
    access_token        => $cfg->{twitter}->{token},
    access_token_secret => $cfg->{twitter}->{token_secret},
) if defined $cfg->{twitter}->{consumer_key};

$poe_kernel->run();

sub twitterpoll {

    # wakes up every twitter->tick seconds and checks for new status for twitter->screen_name
    return unless defined $cfg->{twitter}->{screen_names} and @{$cfg->{twitter}->{screen_names}};
    my $result = eval {
        my $s = $nt->lookup_users({screen_name => $cfg->{twitter}->{screen_names}});
        if (ref $s eq "ARRAY") {
            for (@$s) {
                if (defined $cfg->{twitter}->{$_->{screen_name}}->{status} and defined $_->{status}->{id} and
                        $cfg->{twitter}->{$_->{screen_name}}->{status} ne $_->{status}->{id}) {

                    # new tweet or retweet detected, check if they are really new
                    if (defined $_->{status}->{retweeted_status}) {
                        next if oldstatus($_->{status}->{retweeted_status}->{id});
                    } else {
                        next if oldstatus($_->{status}->{id});
                    }
                    my $text = "https://twitter.com/$_->{screen_name}/status/$_->{status}->{id}\n";

                    if (defined $cfg->{twitter}->{chat_id}) {

                        # we have a seperate channel for twitter feeds
                        relay2tel($cfg->{twitter}->{chat_id},$text);
                    } else {

                        # relay to all chats
                        relay2tel($cfg->{telegram}->{chat_id},$text);
                        relay($cfg->{signal}->{infile},$text);
                        relay($cfg->{irc}->{infile},$text);
                    }
                }
                $cfg->{twitter}->{$_->{screen_name}}->{status} = $_->{status}->{id};
            }
        } else {
            print $dbg "lookup_users failed; ref equals " . ref $s . "\n" if defined $dbg;
        }
    };
    unless ($result) {
        print $@;
        print $dbg $@ if defined $dbg;
    }
}

sub _start {

    # file to be read and send to the channel
    $irc->plugin_add( 'FollowTail' => POE::Component::IRC::Plugin::FollowTail->new(
        filename => $cfg->{irc}->{infile},
    ));
    $irc->yield( register => 'all' );
    $irc->yield( connect => { } );
    return;
}

sub irc_001 {
    my $sender = $_[SENDER];
    my $irc = $sender->get_heap();
    print "Connected to ", $irc->server_name(), "\n";
    print $dbg "Connected to ", $irc->server_name(), "\n" if defined $dbg;

    # we join our channel
    $irc->yield( join => $cfg->{irc}->{channel} );
}

sub irc_public {

    # handle normal messages in irc channel
    my ($sender, $who, $where, $what) = @_[SENDER, ARG0 .. ARG2];
    my $nick = ( split /!/, $who )[0];
    my $text = "[IRC] $nick: $what\n";
    relay2tel($cfg->{telegram}->{chat_id},$text);
    relay($cfg->{signal}->{infile},$text);
}

sub irc_ctcp_action {

    # handle /me events
    my ($sender, $who, $where, $what) = @_[SENDER, ARG0 .. ARG2];
    my $nick = ( split /!/, $who )[0];
    my $text = "[IRC] ***$nick $what\n";
    relay2tel($cfg->{telegram}->{chat_id},$text);
    relay($cfg->{signal}->{infile},$text);
}

sub irc_join {

    # someone joins the channel
    my ($who,$channel) = @_[ARG0, ARG1];
    my $nick = ( split /!/, $who )[0];
    my $text = "[IRC] $nick joined the chat\n";
    if (defined $cfg->{irc}->{showjoin}) {
        relay2tel($cfg->{telegram}->{chat_id},$text);
        relay($cfg->{signal}->{infile},$text);
    }
}

sub irc_quit {

    # someone leaves the channel
    my ($who,$msg) = @_[ARG0, ARG1];
    my $nick = ( split /!/, $who )[0];
    my $text = "[IRC] $nick quit the chat ($msg)\n";
    if (defined $cfg->{irc}->{showquit}) {
        relay2tel($cfg->{telegram}->{chat_id},$text);
        relay($cfg->{signal}->{infile},$text);
    }
}

sub irc_tail_input {

    # handle text added to irc->infile
    my ($kernel, $sender, $input) = @_[KERNEL, SENDER, ARG1];
    $kernel->post( $sender, 'privmsg', $cfg->{irc}->{channel}, $input );
}

sub _default {
    # This will produce some debug info.
    my ($event, $args) = @_[ARG0 .. $#_];
    my @output = ( "$event: " );

    for my $arg (@$args) {
        if ( ref $arg eq 'ARRAY' ) {
            push( @output, '[' . join(', ', @$arg ) . ']' );
        }
        else {
            push ( @output, "'$arg'" );
        }
    }
    print join ' ', @output, "\n";
    print $dbg join ' ', @output, "\n" if defined $dbg;
    die "I got disconnected :( :(\nKilling myself..\n" if grep(/irc_disconnect/,@output);
}

sub relay2tel {
    my ($chat_id,$text) = @_;
    print $text;
    print $dbg $text if defined $dbg;

    # we relay straight to telegram
    my $telmsg;
    eval { $telmsg = uri_escape($text); };
    $telmsg = uri_escape_utf8($text) if $@;
    HTTP::Tiny->new->get( "$URL?chat_id=$chat_id&text=$telmsg" );
}

sub relay {
    my ($file,$text) = @_;

    # write to some file
    open my $w, ">>", $file;
    print $w $text;
    close $w;
}

sub oldstatus {
    my $id = shift;

    # returns empty string if the insert succeeded
    eval {
        my $dbh = DBI->connect("dbi:SQLite:dbname=$cfg->{twitter}->{db}", "", "", { RaiseError => 1 }, );
        $dbh->do("insert into status values ($id)");
    };
    return $@;
}
