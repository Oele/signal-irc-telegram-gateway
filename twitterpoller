#!/usr/bin/perl
#
# When twitter is configured, check for status updates of some twitter screen_names and relay those.
# optionally poll for certain tags and relay those.
#
# 2019, Ruben de Groot

use strict;
use HTTP::Tiny;
use HTML::Entities;
use URI::Escape;
use JSON qw( decode_json );
use Net::Twitter;
use DBI;

open my $fh, '<', "/etc/hermod.json" or die "error opening configuration $!";
my $cfg = decode_json do { local $/; <$fh> };
close $fh;

my $URL = "https://api.telegram.org/bot$cfg->{telegram}->{token}/sendMessage";

die "Missing consumer key" unless defined $cfg->{twitter}->{consumer_key};
die "Missing consumer secret" unless defined $cfg->{twitter}->{consumer_secret};
die "Missing token" unless defined $cfg->{twitter}->{token};
die "Missing token secret" unless defined $cfg->{twitter}->{token_secret};
die "No names or tags defined" unless defined $cfg->{twitter}->{screen_names} or defined $cfg->{twitter}->{tags};
die "No chat_id defined" unless defined $cfg->{twitter}->{chat_id} or defined $cfg->{telegram}->{chat_id};

my $nt = Net::Twitter->new(
    traits   => [qw/API::RESTv1_1/],
    consumer_key        => $cfg->{twitter}->{consumer_key},
    consumer_secret     => $cfg->{twitter}->{consumer_secret},
    access_token        => $cfg->{twitter}->{token},
    access_token_secret => $cfg->{twitter}->{token_secret},
) if defined $cfg->{twitter}->{consumer_key};

# main loop
while (1) {
    namepoll($cfg->{twitter}->{screen_names}) if defined $cfg->{twitter}->{screen_names} and @{$cfg->{twitter}->{screen_names}};
    tagpoll($cfg->{twitter}->{tags}) if defined $cfg->{twitter}->{tags} and @{$cfg->{twitter}->{tags}};
    my $tick = (defined $cfg->{twitter}->{tick}) ? $cfg->{twitter}->{tick} : 300;
    sleep $tick;
}

sub namepoll {

    # wakes up every twitter->tick seconds and checks for new status for twitter->screen_name
    my $names = shift;
    eval {
        my $s = $nt->lookup_users({screen_name => $names});
        if (ref $s ne "ARRAY") {
            return;
        }
        for (@$s) {

            # remember names and id's
            unless (defined $cfg->{twitter}->{$_->{screen_name}}) {
                $cfg->{twitter}->{$_->{screen_name}} = 1;
                $cfg->{twitter}->{ids}->{$_->{status}->{id}} = 1
                    if defined $_->{status}->{id};
                next;
            }

            next if defined $_->{status}->{id} and $_->{status}->{id} =~ /^\d+$/ and
                    defined $cfg->{twitter}->{ids}->{$_->{status}->{id}};
            $cfg->{twitter}->{ids}->{$_->{status}->{id}} = 1
                 if defined $_->{status}->{id};

            next if defined $_->{status}->{retweeted_status}->{id} and
                    $_->{status}->{retweeted_status}->{id} =~ /^\d+$/ and
                    defined $cfg->{twitter}->{ids}->{$_->{status}->{retweeted_status}->{id}};
            $cfg->{twitter}->{ids}->{$_->{status}->{retweeted_status}->{id}} = 1
                 if defined $_->{status}->{retweeted_status}->{id};

            # skip replies if noreply is defined
            next if defined $_->{status}->{in_reply_to_status_id} and
                    $_->{status}->{in_reply_to_status_id} =~ /^\d+$/ and
                    defined $cfg->{twitter}->{noreply};

            # skip retweets if noretweet is defined
            next if defined $_->{status}->{retweeted_status}->{id} and
                    $_->{status}->{retweeted_status}->{id} =~ /^\d+$/ and
                    defined $cfg->{twitter}->{noretweet};

            # new tweet or retweet detected, check if they are really new
            if (defined $_->{status}->{retweeted_status}->{id}) {
                next if oldstatus($_->{status}->{retweeted_status}->{id});
            } else {
                next if oldstatus($_->{status}->{id});
            }

            relay($_->{screen_name},$_->{status}->{id},$_->{status}->{text});
        }
    };
    print $@ if $@;
}

sub tagpoll {

    # wakes up every twitter->tick seconds looking for tags
    my $tags = shift;
    for my $tag (@$tags) {

        eval {
            my $s = $nt->search($tag);
            if (ref $s ne "HASH") {
                print "search for $tag failed; ref equals " . ref $s . "\n";
                return;
            }
            next unless defined $s->{statuses} and @{$s->{statuses}};

            for (@{$s->{statuses}}) {

                # filter known id's
                next unless defined $_->{id};
                next if defined $cfg->{twitter}->{ids}->{$_->{id}};
                $cfg->{twitter}->{ids}->{$_->{id}} = 1;
                next if defined $_->{retweeted_status}->{id} and
                        defined $cfg->{twitter}->{ids}->{$_->{retweeted_status}->{id}};
                $cfg->{twitter}->{ids}->{$_->{retweeted_status}->{id}} = 1;

                # skip if this is the first round of polling
                next unless defined $cfg->{twitter}->{polled};

                next if defined $_->{in_reply_to_status_id} and
                        defined $cfg->{twitter}->{noreply};

                next if defined $_->{retweeted_status}->{id} and
                        defined $cfg->{twitter}->{noretweet};

                next if oldstatus($_->{id});
                next if defined $_->{retweeted_status}->{id} and oldstatus($_->{retweeted_status}->{id});

                relay($_->{user}->{screen_name},$_->{id},$_->{text});
            }
        };
        print $@ if $@;
    }
    $cfg->{twitter}->{polled} = 1;
}

sub relay {
    my ($name,$id,$text) = @_;
    my $http = HTTP::Tiny->new( max_redirect => 0 );
    my $url = "https://twitter.com/$name/status/$id\n";

    my $telmsg;
    eval { $telmsg = uri_escape($url); };
    $telmsg = uri_escape_utf8($url) if $@;
    my $chat_id = (defined $cfg->{twitter}->{chat_id}) ? $cfg->{twitter}->{chat_id} : $cfg->{telegram}->{chat_id};

    HTTP::Tiny->new->get( "$URL?chat_id=$chat_id&text=$telmsg" );
    print "To telegram: $url";

    # the twitter chat_id is supposedly linked to the telegram group
    # write to files to irc, signal unless twitter->chat_id and telegram->forward are defined
    unless (defined $cfg->{twitter}->{chat_id} and defined $cfg->{telegram}->{forward}) {
        for my $file ($cfg->{irc}->{infile}, $cfg->{signal}->{infile}) {
            open my $w, ">>:utf8", $file;
            print $w "[$name] $url";
            for my $line (split /\n/, $text) {

                # try to replace t.co short url's.
                while ($line =~ /(https:\/\/t.co\/[0-9a-zA-Z]{10,})/) {
                    my $tco = $1;
                    my $resp = $http->get( $tco );
                    my $loc = $resp->{headers}->{location} if defined $resp->{headers}->{location};
                    if (defined $loc and $loc =~ /https:\/\/twitter.com\/i\/web\/status\/[0-9]+/) {

                        # Sooo, we have a 280 char tweet; let's find the expanded url
                        my $resp2 = $http->get( $loc );
                        if ($resp2->{success}) {

                            # extract expanded url from html; discard url's in user profile
                            my @urls = grep !/ProfileHeaderCard/, (grep /ata-expanded-url=/, (split /\n/, $resp2->{content}));
                            $urls[0] =~ m/data-expanded-url="([^"]+)/;
                            my $eurl = $1;
                            $line =~ s/$tco/$eurl/ if defined $eurl and $eurl;

                            print "Expanded URL: $eurl\n" if defined $eurl and $eurl;
                        }
                    } elsif (defined $loc and $loc) {
                        $line =~ s/$tco/$loc/;
                    }
                }

                print $w decode_entities "[$name] $line\n" if $line;
            }
            close $w;
        }
    }
}

sub oldstatus {
    my $id = shift;
    return "status id error" unless $id =~ /^\d+$/;

    # returns empty string if the insert succeeded
    eval {
        my $dbh = DBI->connect("dbi:SQLite:dbname=$cfg->{twitter}->{db}", "", "", { RaiseError => 1 }, );
        $dbh->do("insert into status values ($id)");
    };
    return $@;
}
