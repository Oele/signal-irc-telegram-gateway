#!/usr/bin/perl -w
#
# Signal Poller for Hermod Gateway Bot.
#
# Keeping a tail on the tosignal file for messages to send to signal.
# Polling the signal group for new messages. These are send to telegram 
# and irc
#
# 2019-08-23, Ruben de Groot

use strict;
use JSON;
use HTTP::Tiny;
use URI::Escape;
use Text::Unidecode;
use DBI;

my $cfg = "/etc/hermod.json";
open my $fh, '<', $cfg or die "error opening $cfg $!";
my $config = decode_json do { local $/; <$fh> };
$config->{nicks} = getalias($config);

open my $tail, "<", $config->{tosignal} or die @_;
my $inode = (stat($config->{tosignal}))[1];
open my $debug, ">>", $config->{signal_debug} if defined $config->{signal_debug};

# SEEK_END
seek($tail, 0, 2) or die @_;

# tailing the tosignal file for stuff to send
for (;;) {
    # check if logfile hasn't turned over below our feet
    if ($inode != (stat($config->{tosignal}))[1]) {
        close $tail;
        $inode = (stat($config->{tosignal}))[1];
        open($tail,$config->{tosignal}) or next;
    } else {
        # SEEK_CUR
        seek($tail, 0, 1);
    }

    # send new messages to signal group
    my $lines = do { local $/; <$tail> };
    if ($lines) {
        open my $sc, "|-", $config->{signal_cli}, "send", "-g", $config->{signal_gid};
        print $sc $lines;
        close $sc;
    }

    # now poll the signal group for new messages
    my $json = JSON->new->allow_nonref;
    my @lines = qx( $config->{signal_cli} -u $config->{signal_phone} receive --json );
    for my $line (@lines) {
        print $debug $line if defined $config->{signal_debug};
        print $line; chomp $line;
        my $sigmsg = $json->decode($line);
        next unless defined $sigmsg->{envelope}->{dataMessage};
        $sigmsg = $sigmsg->{envelope};
        my $datamsg = $sigmsg->{dataMessage};

        my $sender = (defined $sigmsg->{source}) ? $sigmsg->{source} : "";
        my $group = (defined $datamsg->{groupInfo}->{groupId}) ? $datamsg->{groupInfo}->{groupId} : "";
        my $text = (defined $datamsg->{message}) ? $datamsg->{message} : "";

        # anonymize sender telephone
        my $anonsender = $sender;
        if (defined $config->{nicks}->{$sender}) {
            $anonsender = $config->{nicks}->{$sender};
        } else {
            $anonsender =~ s/.*(\d\d\d\d)$/$config->{signal_anon}-$1/;
            nickhelp($config,$sender,$anonsender);
            setalias($config,$sender,$anonsender);
        }

        # check for setnick command
        if ($text =~ /^!setnick/) {
            (my $nick = $text) =~ s/^!setnick ([\w]+).*$/$1/;
            if ($nick) {
                setalias($config,$sender,$nick);
                $config->{nicks}->{$sender} = $nick;
                $text = "$anonsender is now known as $nick\n";

                # notify all chats
                open my $w, ">>", $config->{tosignal} or die "Died opening tosignal $config->{tosignal}";
                print $w "$text";
                close $w;

                open $w, ">>", $config->{sigfile} or die "Died opening sigfile $config->{sigfile}";
                print $w "[Sg] $text";
                close $w;

                my $URL = "https://api.telegram.org/bot$config->{token}/sendMessage?chat_id=$config->{chat_id}&text=";
                my $telmsg = uri_escape("[Sg] $text");
                my $response = HTTP::Tiny->new->get( "$URL$telmsg" );
                print "$response->{status} $response->{reason}\n";

                next;
            }
        }

        # only relay group messages
        next unless $group eq $config->{signal_gid};

        # relay to telegram
        my $URL = "https://api.telegram.org/bot$config->{token}/sendMessage?chat_id=$config->{chat_id}&text=";
        my $telmsg = uri_escape_utf8("[Sg $anonsender]: $text");
        my $response = HTTP::Tiny->new->get( "$URL$telmsg" );
        print "$response->{status} $response->{reason}\n";

        # relay to IRC
        $text = unidecode($text);
        my @lines = split /\n/, $text;
        open my $w, ">>", $config->{sigfile} or die "Died opening sigfile $config->{sigfile}";
        foreach my $line (@lines) {
            print $w "[Sg $anonsender]: $line\n" if $line;
        }
    }
}

sub getalias {
    my $config = shift;
    my $alias;
    my $dbh = DBI->connect("dbi:SQLite:dbname=$config->{signal_db}", "", "", { RaiseError => 1 }, ) or die $DBI::errstr;
    my $obj = $dbh->prepare("select * from alias");
    $obj->execute() or die $DBI::errstr;

    while (my $row = $obj->fetchrow_hashref()) {
        $alias->{$row->{phone}} = $row->{nick};
    }
    return $alias;
}

sub setalias {
    my ($config,$phone,$nick) = @_;
    my $dbh = DBI->connect("dbi:SQLite:dbname=$config->{signal_db}", "", "", { RaiseError => 1 }, ) or die $DBI::errstr;
    $dbh->do("insert or replace into alias (phone,nick) values (?,?)", undef, $phone, $nick) or die $DBI::errstr;
    $dbh->disconnect();
}

sub nickhelp {
    my ($config,$phone,$nick) = @_;
    my $text = 'You do not have a nickname set. You are now known as '.$nick.'. To change this, simply type !setnick yournickname on a new line in the group or in a private message to me.';
    my $out = qx( $config->{signal_cli} -u $config->{signal_phone} send -m "$text" $phone );
    print $debug $out if defined $config->{signal_debug};
}

